---
title: "The Rega User Guide"
bibliography: Rega-refs.bib
date: "Last edited: `r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Robert IvÃ¡nek"
    affiliation: 
    - Department of Biomedicine, University of Basel, Basel, Switzerland
    - Swiss Institute of Bioinformatics, Basel, Switzerland
    email: robert.ivanek@unibas.ch
  - name: "Igor Cervenka"
    affiliation: 
    - Department of Biomedicine, University of Basel, Basel, Switzerland
    - Swiss Institute of Bioinformatics, Basel, Switzerland
    email: igor.cervenka@unibas.ch
package: "`r BiocStyle::pkg_ver('Rega')`"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: 
    default
abstract: "Rega provides interface to European Genome-Phenome Archive (EGA)."
vignette: >
  %\VignetteIndexEntry{The Rega User Guide}
  %\VignetteKeywords{API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  chunk_output_type: 
    console
---

```{r options, include=FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  eval = FALSE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = NA,
  prompt = FALSE,
  tidy = FALSE,
  dev = "png",
  out.width = "100%"
)

## check the output type
out_type <- opts_knit$get("rmarkdown.pandoc.to")
if (is.null(out_type)) {
  out_type <- "html"
}

## add styling
if (out_type == "html") {
  BiocStyle::markdown()
} else if (out_type == "latex") {
  BiocStyle::latex()
}
```

# Setup credentials

`httr2` is built around the notion that the key should live in an environment variable. So the first step is to make your package key available on your local development machine by adding a line to your your user-level `.Renviron` (which you can easily open with `usethis::edit_r_environ()`)

The `REGA_EGA_PASSWORD` environmental variable isn't supposed to store the password in the plain text, instead:

 - generate a secret key using `httr2::secret_make_key()` and store it as the "REGA_KEY" environmental variable (e.g. using `export` command in bash or in `.Renviron` file)
 - generate an encrypted password using your secret key via `httr2::secret_encrypt("<your-ega-password>", "REGA_KEY")`
 - use the resulting value as "REGA_EGA_PASSWORD"

```{r env-credentials, eval=FALSE}
Sys.setenv("REGA_EGA_USERNAME" = "<your-ega-username>")
Sys.setenv("REGA_EGA_PASSWORD" = "<your-ega-password>")
```

# Authentication

`Rega` package supports authentication through OAuth or Bearer token via functions `ega_oauth` (default) and `ega_token` respectively.

# Data submission

## Submission metadata parsing

The default parser parses the bundled `xlsx` template. Changing the parser behavior, such as whether to append `c4gh` extension to files or which sheets to parse from the metadata files is controlled by YAML config file `inst/extdata/default_parser_params.yaml`. To modify the parameters, create a local copy of the file and pass it as `param_file` argument to `default_parser` function.

```{r parse-metadata}
metadata_file <- "<path-to-metadata-file>"

parsed_metadata <- default_parser(metadata_file)
parsed_metadata
```

## Submission metadata validation

The internal validation is a bit stricter in enforcing uniqueness of titles and descriptions for individual tables (the API itself doesn't have this requirement). If the validation only fails in this particular case, you can still continue with creating the submission. However, there have been instances of failed reviews due to non-unique titles and descriptions before.

```{r validate-metadata}
validation_summary <- default_validator(parsed_metadata)
validation_summary
```

## Create API client

Extract EGA API using the bundled YAML specification

```{r extract-api}
api <- extract_api()
```

Create a client using the embedded `httr2` OAuth authentication (default).

```{r client-with-oauth}
ega <- create_client(api, verbosity = 0)
```

## Run new submission workflow

Specify one of the available workflow function with your parsed metadata and a client as parameters.

```{r run-workflow}
responses <- new_submission(parsed_metadata, ega, "log.yaml")
```

## Other workflows

You can get the entire contents of current submission metadata via `get_submission` workflow.

```{r get-submission-contents}
resp <- get_submission(00001, ega, logfile = "log.yaml")
resp <- get_submission(00001, ega)
```

Or delete the entire contents of current submission metadata via `delete_submission_contents` workflow.

```{r delete-submission-contents}
resp <- delete_submission_contents(00001, ega)
```

Or delete the entire submission by using the `delete_submission` workflow.

```{r delete-submission}
resp <- delete_submission(00001, ega)
```

If you submission has an accession ID and you wish to roll back changes you made
to since last time, you can use `rollback_submission` workflow. Apart from `accession_id` and API client, you need to specify which tables/endpoints you want to roll back.

```{r rollback-submission}
resp <- rollback_submission("EGA00000000001", ega, c("datasets", "runs"))
```

**Workflow for updating the submission metadata by `PUT` method is under development.**

# Utilities

If you wish to create your own templates for EGA submissions, we provide a few functions to retrieve properties and enums through API and save them in text files. We will use the API and the client created above.

Relevant functions include:

-   `get_schemas`
-   `get_properties`
-   `get_enum`
-   `parse_enum`

## Retrieve properties

```{r retrieve-properties}
properties_out <- "properties.txt"

schemas <- get_schemas(api)

for (x in names(schemas)) {
  p <- get_properties(schemas[[x]], filter_ids = FALSE)
  cat(
    paste0("[", x, "]"), p, "",
    file = properties_out, sep = "\n", append = TRUE
  )
}
```

## Retrieve enums

```{r retrieve-enums}
enums_out <- "enums.txt"

for (x in ega$get__enums()$enums) {
  e <- parse_enum(get_enum(ega, x))
  cat(
    paste0("[", x, "]"), e, "",
    file = enums_out, sep = "\n", append = TRUE
  )
}
```

# Notes

## Bearer token authentication

For testing, debugging and prototyping purposes, it is possible to directly use generated bearer token with API when creating the client. It is then your responsibility of the user to track the validity and refresh the token as necessary.

```{r client-with-token, eval=FALSE}
bt <- ega_token()
ega <- create_client(api, bt$access_token)

ega$get__enums()
```

## Creating the YAML specification for API client generation

The [EGA API yaml](https://submission.ega-archive.org/api/spec/#/) was download from EGA Submitter API website and references were resolved using [Swagger Editor](https://editor.swagger.io/). The resolved API YAML specification is bundled with the package.

Following changes were made in the YAML specification for the package to work correctly.

- `servers/url` needs to be changed to: `https://submission.ega-archive.org/api>`
- The schemas for Datasets are not completely correct. There is a possibility to submit a dataset without Runs and Analyses, but this is not reflected in the API. The requirement for `run_provisional_ids` and `analysis_provisional_ids` was commented out in the resolved YAML file to allow for this case. It was added to the unresolved YAML (corresponds to lines `13322` and `13323`). 


# Issues
